{% extends 'dashboard.html' %}
{% block title %} sankey {% endblock %}
{% block additional_js %}
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
{% endblock %}
{% block dash_content %}
<style>

    .node rect {
      cursor: move;
      fill-opacity: .9;
      shape-rendering: crispEdges;
    }
    
    .node text {
      pointer-events: none;
      text-shadow: 0 1px 0 #fff;
    }
    
    .link {
      fill: none;
      stroke: #000;
      stroke-opacity: .2;
    }
    
    .link:hover {
      stroke-opacity: .5;
    }
    
    </style>

    <body>
        <div id="content" class="container">
            <div id="cycle-info">
                <form>
                    <div class="form-group">
                        <textarea class="form-control" rows="10" id="cycle-text">{{ cycle_info }}</textarea>
                    </div>
                </form>
                <form>
                    <button class="btn btn-primary rounded normal_list" type="button" style="margin: 3px;" onclick="updateData()" >Update Graph</button>
                </form>
            </div>
            
            <div id="chart"></div>
        
        </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
    <script src="{{ url_for('static', filename='/js/sankey.js') }}"></script>
    <script>        
    var units = "Actions";
    
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = document.getElementById("chart").offsetWidth - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;
    
    var formatNumber = d3.format(",.0f"),    // zero decimal places
        format = function(d) { return formatNumber(d) + " " + units; },
        color = d3.scale.category20();
    
    // append the svg canvas to the page
    var svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");
    
    // Set the sankey diagram properties
    var sankey = d3.sankey()
        .nodeWidth(36)
        .nodePadding(40)
        .size([width, height]);
    
    var path = sankey.link();

    var labels = ["source","target","value"];
    var array = document.getElementById("cycle-text").value.split("\n");

    var lst = [];

    for (var a=0; a < array.length; a++){
        var elem = array[a].split(",");
        var obj = {};
        for (var b=0; b< elem.length; b++){
                obj[labels[b]] = elem[b];
            }
        lst.push(obj);
    }

    var data = lst;

    //set up graph in same style as original example but empty
    graph = {"nodes" : [], "links" : []};
    
    data.forEach(function (d) {
        graph.nodes.push({ "name": d.source });
        graph.nodes.push({ "name": d.target });
        graph.links.push({ "source": d.source,
                            "target": d.target,
                            "value": +d.value });
        });

        // return only the distinct / unique nodes
        graph.nodes = d3.keys(d3.nest()
        .key(function (d) { return d.name; })
        .map(graph.nodes));

        // loop through each link replacing the text with its index from node
        graph.links.forEach(function (d, i) {
        graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
        graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
        });

        //now loop through each nodes to make nodes an array of objects
        // rather than an array of strings
        graph.nodes.forEach(function (d, i) {
        graph.nodes[i] = { "name": d };
        });

    sankey
    .nodes(graph.nodes)
    .links(graph.links)
    .layout(32);

    // add in the links
    var link = svg.append("g").selectAll(".link")
        .data(graph.links)
        .enter().append("path")
        .attr("class", "link")
        .attr("d", path)
        .style("stroke-width", function(d) { return Math.max(1, d.dy); })
        .sort(function(a, b) { return b.dy - a.dy; });

    // add the link titles
    link.append("title")
        .text(function(d) {
            return d.source.name + " → " + 
                d.target.name + "\n" + format(d.value); });

    // add in the nodes
    var node = svg.append("g").selectAll(".node")
        .data(graph.nodes)
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", function(d) { 
            return "translate(" + d.x + "," + d.y + ")"; })
        .call(d3.behavior.drag()
        .origin(function(d) { return d; })
        .on("dragstart", function() { 
            this.parentNode.appendChild(this); })
        .on("drag", dragmove));

    // add the rectangles for the nodes
    node.append("rect")
        .attr("height", function(d) { return d.dy; })
        .attr("width", sankey.nodeWidth())
        .style("fill", function(d) { 
            return d.color = color(d.name.replace(/ .*/, "")); })
        .style("stroke", function(d) { 
            return d3.rgb(d.color).darker(2); })
        .append("title")
        .text(function(d) { 
            return d.name + "\n" + format(d.value); });

    // add in the title for the nodes
    node.append("text")
        .attr("x", -6)
        .attr("y", function(d) { return d.dy / 2; })
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .attr("transform", null)
        .text(function(d) { return d.name; })
        .filter(function(d) { return d.x < width / 2; })
        .attr("x", 6 + sankey.nodeWidth())
        .attr("text-anchor", "start");

    // the function for moving the nodes
    function dragmove(d) {
        d3.select(this).attr("transform", 
        "translate(" + (
            d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))
            ) + "," + (
                d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
                ) + ")");
        sankey.relayout();
        link.attr("d", path);
    }
    ;
    // ** Update data section (Called from the onclick)
function updateData() {
    d3.selectAll("g > *").remove();
    

    var labels = ["source","target","value"];
    var array = document.getElementById("cycle-text").value.split("\n");

    var lst = [];

    for (var a=0; a < array.length; a++){
        var elem = array[a].split(",");
        var obj = {};
        for (var b=0; b< elem.length; b++){
                obj[labels[b]] = elem[b];
            }
        lst.push(obj);
    }

    var data = lst;

    //set up graph in same style as original example but empty
    graph = {"nodes" : [], "links" : []};
    
    data.forEach(function (d) {
        graph.nodes.push({ "name": d.source });
        graph.nodes.push({ "name": d.target });
        graph.links.push({ "source": d.source,
                            "target": d.target,
                            "value": +d.value });
        });

        // return only the distinct / unique nodes
        graph.nodes = d3.keys(d3.nest()
        .key(function (d) { return d.name; })
        .map(graph.nodes));

        // loop through each link replacing the text with its index from node
        graph.links.forEach(function (d, i) {
        graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
        graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
        });

        //now loop through each nodes to make nodes an array of objects
        // rather than an array of strings
        graph.nodes.forEach(function (d, i) {
        graph.nodes[i] = { "name": d };
        });

    sankey
    .nodes(graph.nodes)
    .links(graph.links)
    .layout(32);

    // add in the links
    var link = svg.append("g").selectAll(".link")
        .data(graph.links)
    .enter().append("path")
        .attr("class", "link")
        .attr("d", path)
        .style("stroke-width", function(d) { return Math.max(1, d.dy); })
        .sort(function(a, b) { return b.dy - a.dy; });

    // add the link titles
    link.append("title")
        .text(function(d) {
            return d.source.name + " → " + 
                d.target.name + "\n" + format(d.value); });

    // add in the nodes
    var node = svg.append("g").selectAll(".node")
        .data(graph.nodes)
    .enter().append("g")
        .attr("class", "node")
        .attr("transform", function(d) { 
            return "translate(" + d.x + "," + d.y + ")"; })
    .call(d3.behavior.drag()
        .origin(function(d) { return d; })
        .on("dragstart", function() { 
            this.parentNode.appendChild(this); })
        .on("drag", dragmove));

    // add the rectangles for the nodes
    node.append("rect")
        .attr("height", function(d) { return d.dy; })
        .attr("width", sankey.nodeWidth())
        .style("fill", function(d) { 
            return d.color = color(d.name.replace(/ .*/, "")); })
        .style("stroke", function(d) { 
            return d3.rgb(d.color).darker(2); })
    .append("title")
        .text(function(d) { 
            return d.name + "\n" + format(d.value); });

    // add in the title for the nodes
    node.append("text")
        .attr("x", -6)
        .attr("y", function(d) { return d.dy / 2; })
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .attr("transform", null)
        .text(function(d) { return d.name; })
    .filter(function(d) { return d.x < width / 2; })
        .attr("x", 6 + sankey.nodeWidth())
        .attr("text-anchor", "start");
    // the function for moving the nodes
    function dragmove(d) {
        d3.select(this).attr("transform", 
        "translate(" + (
            d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))
            ) + "," + (
                d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
                ) + ")");
        sankey.relayout();
        link.attr("d", path);
    }
}

    
    </script>
    
    </body>
{% endblock %}